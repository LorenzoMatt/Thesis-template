% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione e codifica}
\label{cap:progettazione-codifica}
%**************************************************************

\intro{Il seguente capitolo descrive gli strumenti e la progettazione con cui sono 
state implementate le integrazione con la \textit{web-app} \productName.}\\

%**************************************************************
\section{Tecnologie}
\label{sec:tecnologie-strumenti}

Di seguito viene data una panoramica delle tecnologie e strumenti utilizzati.

\subsection*{Java}
Java è un linguaggio di programmazione e una piattaforma di elaborazione 
rilasciato per la prima volta da Sun Microsystems nel 1995. Si è evoluto da umili
 origini per sostenere gran parte del mondo digitale di oggi, fornendo una
 piattaforma affidabile su cui sono costruiti molti servizi e applicazioni. 
 Anche i nuovi prodotti, innovativi nei servizi digitali progettati per il futuro,  
 continuano a fare affidamento su Java.
%TODO: aggiungere bibliografia, link: https://java.com/en/download/help/whatis_java.html
\subsection*{Spring}
Spring è un \textit{framework} open source per lo sviluppo di applicazioni su piattaforma Java.
A questo \textit{framework} sono associati tanti altri progetti, che hanno nomi composti come 
Spring Boot, Spring Data, Spring Batch, etc. Questi progetti sono stati ideati per
fornire funzionalità aggiuntive al \textit{framework}.
%TODO: aggiungere bibliografia, link: https://it.wikipedia.org/wiki/Spring_Framework

\subsection*{Typescript}
%**************************************************************
TypeScript è un linguaggio di programmazione sviluppato e gestito da Microsoft. 
È un \gls{superset} di JavaScript, che permette di aggiungere la tipizzazione 
statica opzionale al linguaggio. TypeScript è progettato per lo sviluppo di applicazioni 
di grandi dimensioni e per la \gls{transcompilazione} in JavaScript. Poiché TypeScript è un \gls{superset} di JavaScript, anche i programmi JavaScript esistenti sono validi programmi TypeScript.
%TODO: aggiungere bibliografia, link: https://en.wikipedia.org/wiki/TypeScript

\subsection*{Angular}
%**************************************************************
Angular è un \textit{framework} JavaScript per applicazioni \textit{web} dinamiche, utilizzato in particolare per la creazione di \gls{spa} e \textit{web-app}. Consente di utilizzare HTML come linguaggio template e di estenderne la sintassi per esprimere le componenti di un'applicazione in modo chiaro e succinto.
%TODO: aggiungere bibliografia, link: https://psicografici.com/angular-js/#:~:text=Angular%20%C3%A8%20un%20framework%20JavaScript,in%20modo%20chiaro%20e%20succinto.

\subsection*{Angular Material}
%**************************************************************
Angular Material è una libreria sviluppata da Google nel 2014 progettata per aiutare a sviluppare pagine \textit{web} in modo strutturato. \\
I suoi componenti aiutano a creare pagine \textit{web} e applicazioni \textit{web} attraenti, coerenti e funzionali.
%TODO: aggiungere bibliografia, link: https://psicografici.com/angular-js/#:~:text=Angular%20%C3%A8%20un%20framework%20JavaScript,in%20modo%20chiaro%20e%20succinto.

\subsection*{Node.js}
Node.js è una piattaforma di sviluppo open source per l'esecuzione di codice JavaScript lato \textit{server}. Node è utile per sviluppare applicazioni che richiedono una connessione permanente dal \textit{browser} al \textit{server} ed è spesso utilizzato per applicazioni in tempo reale come chat, feed di notizie e di notifiche.\\
Node.js è utilizzato da Angular per gestire le dipendenze, permettendo la dichiarazione di due insiemi di dipendenze: per gli sviluppatori e per far funzionare l'applicativo. In questo modo è possibile differenziare quali librerie si possono tralasciare in fase di \textit{deploy} dell'applicazione perché, ad esempio, necessarie solo per effettuare i test.
%TODO: aggiungere bibliografia, link: https://whatis.techtarget.com/definition/Nodejs#:~:text=James%20Denman-,Node.,feeds%20and%20web%20push%20notifications.

%**************************************************************
\section{Progettazione}
\label{sec:progettazione}

\subsection{Back end}
\subsubsection{Architettura Spring Boot}
Spring Boot è un modulo di Spring \textit{framework}. Viene utilizzato per creare applicazioni \textit{stand-alone} di livello produttivo con il minimo sforzo.\\
Spring Boot segue un'architettura a strati, in cui ogni livello comunica con gli strati vicini.\\
Ci sono quattro strati in Spring Boot sono i seguenti:
\begin{itemize}
    \item \textbf{\textit{Presentation layer}:} gestisce le richieste HTTP, trasforma il il parametro da formato JSON in classe e autentica la richiesta, per poi trasferirla al \textit{business layer};
    \item \textbf{\textit{Business Layer}:} gestisce tutta la \textit{business logic}. Consiste in classi di servizio e utilizza servizi forniti dagli strati di accesso ai dati;
    \item \textbf{\textit{Persistence Layer}:} contiene tutta la \textit{storage logic}, e trasformando gli oggetti provenienti dalla \textit{business logic} in righe del \textit{database};
    \item \textbf{\textit{Database Layer}:} in questo strato sono effettuate le operazioni \gls{CRUD}.
\end{itemize}
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.3]{spring-boot-architecture-layer.png} 
    \caption{Architettura a strati di Spring Boot}
\end{figure}

\subsubsection{Spring Boot Flow Architecture}
% https://codingjam.it/microservizi-in-java-con-spring-boot-e-spring-cloud/
\begin{figure}[H] 
    \centering 
    \includegraphics[width=1\columnwidth]{spring-boot-architecture.png} 
    \caption{Spring Boot \textit{workflow}}
\end{figure}
Il \textit{workflow} con cui vengono effettuate richieste HTTP utilizzando Spring Boot è il seguente:
\begin{itemize}
    \item il client esegue una richiesta HTTP (GET, POST, PUT O DELETE) ad un   \gls{endpoint} esposto;
    \item la richiesta va al \textit{controller}, che mappa la richiesta e la gestisce. Dopodiché chiama la \textit{service logic};
    \item nel \textit{service layer} viene eseguita la \textit{business logic}. Vengono eseguite le operazioni sulle classi mappate nel \textit{database};
    \item il \textit{repository} \textit{JpaRepository} esegue le operazioni sul database;
    \item una pagina \gls{JSP} viene restituita all'utente se non si è verificato un errore.
\end{itemize} 

\subsubsection{Organizzazione del codice}

\begin{figure}[H] 
    \centering 
    \includegraphics[width=0.65\columnwidth]{organizzazione_codice_spring.png} 
    \caption{Organizzazione del codice}
\end{figure}
Per inizializzare un nuovo \gls{microservizio} viene utilizzata l'estensione \textbf{Spring Initializr} per Visual Studio Code, che permette la generazione di un progetto per Spring Boot.\\
La cartella che contiene il codice del \gls{microservizio} è \texttt{src\textbackslash main\textbackslash java\textbackslash sportwill\textbackslash Gruppi}, che contiene le seguenti cartelle: 
\begin{itemize}
    \item \texttt{controller}: contiene la classe che mappa le richieste HTTP ai metodi specifici;
    \item \texttt{entities}: contiene le classi entità, ovvero classi che rappresentano delle tabelle in un \textit{database} relazionale e ogni istanza di entità corrisponde a una riga in quella tabella;
    \item \texttt{exceptions}: insieme di classi che estendono la classe Exception;
    \item \texttt{services}: classi che compongono il \textit{service layer}.


\end{itemize}
% TODO aggiungere alla bibliografia: https://microservices.io/patterns/apigateway.html
\subsubsection{Progettazione delle API}
Il \textit{back end} del progetto è strutturato a \glspl{microservizio}, ognuno contenente una business logic atta a soddisfare un certo tipo di richieste.\\
Il \textit{front end} comunica con il \textit{back end} attraverso gli \gls{endpoint} che ogni \gls{microservizio} espone. \\
Tuttavia, effettuare connessioni dirette fra \textit{front end} e ogni \gls{microservizio} presenta alcuni problemi, come: 
\begin{itemize}
    \item numerose connessioni a seconda della quantità dei \glspl{microservizio};
    \item i \glspl{microservizio} devono esporre pubblicamente il proprio \gls{IP}, causando problemi sia di sicurezza, dovuta all'esposizione degli indirizzi IP al mondo esterno, sia in fase di latenza, ovvero il tempo che intercorre tra l'invio di una richiesta ed una risposta tenderà ad essere
    sempre più alto.
\end{itemize}

\noindent Per far fronte a queste problematiche si è deciso di utilizzare un \gls{API Gateway}.\\
In questo modo, solamente un \gls{IP} sarà visibile pubblicamente, mentre quelli dei \glspl{microservizio} possono diventare privati.\\
Per quanto riguarda la latenza il \textit{front end} comunicherà attraverso l'\gls{API Gateway}, stabilendo solo le connessioni per la richiesta e la risposta, lasciando all'\gls{API Gateway} il compito di smistare le richieste al giusto \gls{microservizio}, permettendo una connessione più rapida rispetto  all'utilizzo di connessioni diverse per ogni \gls{microservizio}, essendo tutti all'interno dello stesso \textit{network}.

\subsection{Front end}
\subsubsection{Architettura Angular}
% TODO aggiungere alla bibliografia: https://angular.io/guide/architecture
Il componente principale di Angular è il \textbf{modulo}. Un modulo è un contenitore di funzionalità che sono es
poste ad altri moduli. Questa suddivisione in moduli rende la struttura dell'applicazione ordinata e il codice mantenibile.\\
Un elemento fondamentale di Angular è il \textbf{component}, ovvero delle classi che gestiscono le \textit{view} dell'applicazione e la loro logica.\\
I dati da visualizzare nella \textit{view} vengono forniti dalle classi dette \textbf{servizi}. Queste classi svolgono diverse funzioni, come per esempio  l'esecuzione delle richieste HTTP.\\  
Ad ogni component è associato un \textit{template}, ovvero del codice HTML in cui si definisce come viene visualizzato il component.\\
È possibile personalizzare il codice HTML utilizzando le \textbf{direttive}, ovvero delle classi che aggiungono un comportamento aggiuntivo agli elementi nelle applicazioni Angular. Le direttive integrate di Angular permettono di gestire moduli, elenchi, stili e ciò che gli utenti vedono.\\
È possibile creare un component che rappresenta la pagina completa, in cui inserire diversi component per ogni elemento contenuto in quella pagina.
Ogni component contenuto si occuperà così di gestire la grafica di quella determinata funzionalità e di comunicare con i servizi di cui necessita; sarà poi il component \enquote*{padre} a gestire la disposizione dei component utilizzati. 
\subsubsection{Organizzazione del codice}
% TODO: aggiungere questa sezione alla parte di codifica
\subsubsection{Progettazione delle maschere}
Con il \textit{tutor} aziendale è stato discusso come dovrebbe essere la grafica delle nuove maschere da aggiungere a \productName. Da queste discussioni è stato poi utilizzato \nameref{sub:Figma} per fare il \textit{mockup}, in modo da  testare come i vari elementi visivi lavorano insieme.\\
Durante la progettazione del \textit{mockup} è stato seguito lo stile presente nella \textit{web-app}, in modo da non disorientare l'utente durante la navigazione. \\
I risultati della progettazione sono riportati in seguito.
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.6]{mockup/le-mie-crew.png} 
    \caption{Mockup pagina per la visualizzazione dei gruppi creati dall'utente}
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.6]{mockup/lista-crew.png} 
    \caption{Mockup pagina per la visualizzazione dei gruppi a cui partecipa l'utente}
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.54]{mockup/dettagli-crew.png} 
    \caption{Mockup pagina per la visualizzazione dei dettagli di un gruppo}
\end{figure}

\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.54]{mockup/modifica-crew.png} 
    \caption{Mockup pagina per la modifica dei dettagli di un gruppo}
\end{figure}

Come si può notare dalle immagini, sono stati omessi dalla progettazione l'header e il footer, in quanto sono già presenti nella \textit{web-app}.


% \subsubsection{Namespace 1} %**************************
% Descrizione namespace 1.

% \begin{namespacedesc}
%     \classdesc{Classe 1}{Descrizione classe 1}
%     \classdesc{Classe 2}{Descrizione classe 2}
% \end{namespacedesc}


%**************************************************************
\section{Design Pattern utilizzati}
\subsection{Microservizi}
% TODO: aggiungere alla bibliografia: https://aws.amazon.com/it/microservices/
I \glspl{microservizio} sono un approccio per lo sviluppo e l'organizzazione dell'architettura \textit{software} secondo cui quest'ultimi sono composti di servizi indipendenti di piccole dimensioni che comunicano tra loro tramite \gls{API} ben definite.\\
Nel contesto di questo progetto, sono stati implementati tre \glspl{microservizio}: 
\begin{itemize}
    \item \textbf{SW\_Gruppi}: \gls{microservizio} responsabile per la gestione delle funzionalità legate ai gruppi;
    \item \textbf{ApiGateway}: \gls{microservizio} che implementa il \textit{pattern} \nameref{sub:ApiGateway};
    \item \textbf{EurekaServer}: \gls{microservizio} che implementa il pattern \hyperref[sub:ServiceRegistry]{ServiceRegistry}. 
\end{itemize}
\subsection{API Gateway}
\label{sub:ApiGateway}
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.68]{progettazione/API-Gateway.png} 
    \caption{Diagramma concettuale che descrive l'API Gateway}
\end{figure}
Un \gls{API Gateway} è uno strumento di gestione delle \gls{API} che si situa tra un \textit{client} e una raccolta di servizi \textit{back end}. Un \gls{API Gateway} si comporta come un \textit{proxy} inverso per riceve tutte le chiamate \gls{API}, aggregando le chiamate alle \gls{API} dei servizi richiesti, gestendo e restituendo i risultati appropriati in base alle richieste ricevute.\\
Utilizzare un \gls{API Gateway} è vantaggioso perché: 
\begin{itemize}
    \item permette di centralizzare il punto di ingresso per le chiamate;
    \item permette di monitorare le risorse utilizzate;
    \item permette di proteggere un servizio che è aperto a tutti;
    \item ha latenza minore rispetto alla chiamata a diversi servizi.
\end{itemize}

\subsection{Client-Side Service Discovery e Service Registry}
\label{sub:ServiceRegistry}
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.4]{progettazione/registrazione-servizi.png} 
    \caption{Diagramma concettuale che descrive la registrazione dei microservizi all'Eureka Server}
\end{figure}
%TODO: aggungere bibliografia: https://lalverma.medium.com/spring-boot-microservices-implementing-service-discovery-cfc98e49b74f, https://microservices.io/patterns/service-registry.html
I \glspl{microservizio} hanno una natura dinamica, in quanto è possibile che più istanze di un singolo \gls{microservizio} coesistano, probabilmente esponendo le loro \gls{API} in un indirizzo \gls{IP} diverso o in una porta diversa. Queste evenienze portano all'impossibilità di: 
\begin{itemize}
    \item conoscere la posizione di qualsiasi istanza dei \glspl{microservizio};
    \item tenere traccia di tutte le istanze;
    \item selezionare un'istanza di \gls{microservizio}.
\end{itemize}
La soluzione a questi problemi è l'utilizzo del \textit{pattern} \textbf{\textit{Client-side Service Discovery}}, che fornisce un meccanismo che tiene traccia di tutti i servizi e delle relative istanze. Tutti i \glspl{microservizio} si registrano ad un \textit{Service registry} e continuano ad aggiornare regolarmente le proprie informazioni di rete.\\
Il \textit{pattern} \textbf{\textit{Service registry}} è stato applicato mediante l'implementazione di un \class{Eureka Server}. L'\textit{Eureka Server} è un \textit{database} di servizi che tiene traccia di ogni \gls{microservizio}, delle loro istanze e delle loro locazioni. I \glspl{microservizio} si registrano all'avvio dell'applicazione e vengono rimossi alla sua chiusura.\\
L'utilizzo di questi \textit{pattern}  permette ai servizi di comunicare fra di loro, ottenendo le informazioni degli altri servizi direttamente dall'Eureka Server.
\subsection{Dependency Injection}
\label{sub:Dependency-Injection}
% TODO: aggiungere alla bibliografia: https://davioooh.com/blog/2017/08/19/spring-dependency-injection
Sia Angular sia Spring sono dei \textit{framework} che implementano delle convenzioni che permettono l'utilizzo del \textit{patter} \class{Dependency Injection}.\\
L'ecosistema all'interno del quale le applicazioni Spring vivono viene definito \textbf{IoC container}. Lo \textit{IoC container} si occupa di istanziare gli oggetti (\textit{beans}) dichiarati nel progetto e di reperire e iniettare tutte le dipendenze ad essi associate. Tali dipendenze possono essere componenti del \textit{framework} o altri \textit{bean} dichiarati nel contesto applicativo.\\
La dichiarazione di una classe come componente nel progetto avviene tramite l'utilizzo dell'annotazione \code{@Component}, che rappresenta la categoria più generica per la dichiarazione di un componente.
Durante la fase di codifica del progetto sono state utilizzate le annotazioni \code{@Controller}, \code{@Service} e \code{@Repository}, che sono le categorie di componenti principali di un'applicazione Spring.\\
Per iniettare delle classi da recuperare dal \textit{IoC container} è sufficiente utilizzare l'annotazione \code{@Autowired}.
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.2]{progettazione/autowired-code.png}
    \caption{Esempio di Dependency Injection con Spring}
\end{figure}
% TODO: aggiungere alla bibliografia: https://angular.io/guide/dependency-injection
\noindent Angular permette l'utilizzo della \textit{Dependency Injection} di tipo \textit{constructor}, che prevede che una classe dichiari nel costruttore le dipendenze di cui ha bisogno che in fase di inizializzazione gli verranno fornite.\\
Angular include un meccanismo di \textit{Dependency Injection} davvero solido e molto flessibile, il cui utilizzo si può riassumere in due semplici passi: si crea il servizio e si inietta la dipendenza ove necessario.\\
Nel dettaglio, le fasi sono le seguenti: 
\begin{itemize}
    \item si crea un servizio, ovvero una classe Angular, che viene annotata come \code{@Injectable}. Di \textit{default}, questo decoratore ha una proprietà \code{ProvideIn}, che crea un \textit{provider} per il servizio. Nel caso, per esempio, di \code{ProvideIn: `root'}, viene specificato  che Angular dovrebbe fornire il servizio nella \textit{root injector}, ovvero diponibile a tutte le classi;
    \begin{figure}[H] 
        \centering 
        \includegraphics[scale=0.2]{progettazione/injectable.png}
        \caption{Esempio di creazione di un servizio}
    \end{figure}
    \item  si inietta il servizio e lo si utilizza ovunque sia necessario.
    \begin{figure}[H] 
        \centering 
        \includegraphics[scale=0.2]{progettazione/injected-service.png}
        \caption{Esempio di \textit{constructor injection}}
    \end{figure}
\end{itemize}
\subsection{Singleton}
\label{sub:Singleton}
%TODO: aggiungere alla bibliografia: https://refactoring.guru/design-patterns/singleton
Angular e Spring integrano fra i loro \textit{pattern} il \class{Singleton}, che viene implementato mediante l'utilizzo della \nameref{sub:Dependency-Injection}.\\
Utilizzando questo \textit{pattern} è stato possibile creare una sola istanza di una classe, potendola utilizzare fra i vari servizi e componenti.\\
L'utilizzo del \textit{pattern Singleton}, tuttavia, potrebbe violare il \gls{SRP}, rendendolo un \textit{anti-pattern}. Nel contesto del progetto di \textit{stage}, questo \textit{pattern} è stato utilizzato per le classi di tipo \textit{Controller}, \textit{Service} e \textit{Repository}. In questo caso il suo utilizzo è necessario in quanto sarebbe logicamente sbagliato avere più istanze per il tipo di classi sopra citate.

\subsection{Feature Service}
%TODO: aggiungere alla bibliografia: https://angular.io/guide/feature-modules
Questo \textit{pattern} è utilizzato da Angular per estrarre da una classe di tipo \textit{Component} la sua relativa logica, che può essere per esempio la visualizzazione dei dettagli di un gruppo.\\
 Mediante l'utilizzo del \textit{pattern} \nameref{sub:Singleton} e \nameref{sub:Dependency-Injection} è possibile utilizzare i vari componenti in tutti i componenti dell'applicazione.
\subsection{Lazy Loading}
%TODO: aggiungere alla bibliografia: https://angular.io/guide/lazy-loading-ngmodules
Questo \textit{pattern} è utilizzato da Angular per caricare i moduli solo nel momento in cui effettivamente vengono utilizzati, ottenendo così bassa la quantità di dati scaricata dall'utente iniziale e una diminuzione del tempo necessario al caricamento dell'applicazione.\\
Viene utilizzato questo \textit{pattern} per la gestione del \textit{routing}, associando ad una specifica \textit{view} dell'applicazione un \textit{path} di navigazione presente nella \gls{URL}.
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.3]{progettazione/routing.png}
    \caption{Implementazione del \textit{pattern} \textit{Lazy loading} nel \class{AppRoutingModule}}
\end{figure}
\subsection{Observer}
%TODO: aggiungere alla bibliografia: https://angular.io/guide/observables
% Il pattern \class{Observable} consente a un oggetto, chiamato \class{Subject}, di tenere traccia di altri oggetti, chiamati \class{Observer}, interessati allo stato del \textit{Subject}. Quando lo stato del \textit{Subject} cambia, notifica i suoi \textit{Observer}.\\
Gli \textit{\textbf{Observable}} forniscono supporto per il passaggio di messaggi tra le parti dell'applicazione. Sono usati frequentemente in Angular e sono una tecnica per la gestione ad eventi e la programmazione asincrona.\\
Il \textit{pattern Observer} è un \textit{design pattern} in cui un oggetto, chiamato \class{Subject}, contiene una lista di suoi osservatori, chiamati \class{Observers}, e li notifica automaticamente ai cambiamenti di stato.\\
Gli \textit{Observable} sono dichiarativi, ovvero viene definita una funzione che non viene eseguita fino a quando un \textit{Observer} si sottoscrive ad esso. L'\textit{Observer} viene quindi notificato al completamento della funzione, e il tipo di ritorno di un \textit{Observable} può cambiare in base al contesto, che nel caso nel progetto di \textit{stage} è stato prevalentemente di tipo HTTP \textit{response}. \\
\begin{figure}[H] 
    \centering 
    \includegraphics[scale=0.28]{progettazione/subscribe-example.png}
    \caption{Esempio implementazione \textit{pattern Observer}}
\end{figure}

% Gli \textit{\textbf{Observable}} forniscono supporto per il passaggio di messaggi tra parti dell'applicazione. Sono usati frequentemente in Angular e sono una tecnica per la gestione degli eventi, la programmazione asincrona e la gestione di più valori.

%**************************************************************
\section{Codifica}
\subsection{Back end}

\subsubsection{Gruppi service}
\subsubsection{Modifica dei servizi esistenti}
\subsubsection{Api Gateway ed Eureka Server}
\subsubsection{Docker}

\subsection{Front end}
\subsubsection{Maschere}
\subsubsection{Componenti}